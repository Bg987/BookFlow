const { v4: uuidv4 } = require("uuid");
const bcrypt = require("bcrypt");
const {uploadToCloudinary} = require("../config/cloudinary");
const Username = require("../models/username");
const Librarian = require("../models/Librarian");
const { handleLogin } = require("../utils/logincommon");
const Library = require("../models/Library");
const { sendMail } = require("../config/mail");
const { getSignedUrl } = require("../config/cloudinary");
const stream = require("stream");
const {addLibrarianEmail,LibrarianVerifiedHTML} = require("../utils/EmailsTemplate");

exports.addLibrarian = async (req, res) => {
  let Uid;
  try {
    const lib_id = req.user.referenceId; // library referenceId from middleware
    const { name, dob, email, username } = req.body;
    const profilePic = req.file;

    // Basic validation
    if (!name || !dob || !email || !username || !profilePic) {
      return res.status(400).json({ message: "All fields are required" });
    }
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(email)) {
      return res.status(400).json({ message: "Invalid email format." });
    }
    // Check username and email
    const usernameExists = await Username.findOne({ username });
    if (usernameExists)
      return res.status(400).json({
        message: "Username already taken. Please choose another.",
      });

    const emailExists = await Username.findOne({ email });
    if (emailExists)
      return res.status(409).json({ message: "Email already registered" });

    // Generate credentials and unique IDs
    const randomPassword = Math.random().toString(36).slice(-8);
    const hashedPassword = await bcrypt.hash(randomPassword, 10);
    const uniqueId = uuidv4();
    Uid = uniqueId;
    // Verification token setup
    const verificationToken = uuidv4();
    const verificationExpire = new Date(Date.now() + 24 * 60 * 60 * 1000*15); // 15 days days

    // Step 1: Insert into MongoDB
    const newUser = await Username.create({
      username,
      email,
      password: hashedPassword,
      role: "librarian",
      referenceId: uniqueId,
      tempToken: verificationToken,
      tokenExpire: verificationExpire,
    });
    // Step 2: Insert into SQL
    const newLibrarian = await Librarian.create({
      librarian_id: uniqueId,
      lib_id,
      name,
      dob,
      is_verified: false,
    });

    const profilePicUrl = await uploadToCloudinary(
      profilePic.buffer,
      "BookFlow/Profile_Pictures/librarians",
      "librarian_"
    );
    newUser.profilePicUrl = profilePicUrl;
    await newUser.save();

    const verifyLink = `${process.env.BACKEND_URL}/api/librarian/verify-librarian?token=${verificationToken}`;
    const subject = "BookFlow Librarian Account Created";
    const mailData = addLibrarianEmail(name, username, randomPassword, verifyLink);
    console.log(mailData);
    //const x = await sendMail(email, subject, mailData);
    // if (!x) {
    //   throw new Error("error in email!");
    // }
    res.status(201).json({
      message:
        "Librarian added successfully,Verification Email send successfully",
    });
  } catch (error) {
    if (Uid) {
      try {
        // Delete from MongoDB
        await Username.deleteOne({ referenceId: Uid });
        // Delete from SQL
        await Librarian.destroy({ where: { librarian_id: Uid } });
      } catch (rollbackError) {
        console.error("Rollback failed:", rollbackError);
      }
    }
    console.log("error in librarien ",error);
    res.status(500).json({ message: "Internal Server Error" });
  }
};


exports.verifyLibrarian = async (req, res) => {
  try {
    const { token } = req.query;

    if (!token) {
      return res.status(400).json({ message: "Invalid verification link" });
    }

    // Find the user by token
    const user = await Username.findOne({ tempToken: token });

    if (!user) {
      return res.status(400).json({ message: "Invalid token" });
    }

    // Check if token is expired
    if (user.tokenExpire < new Date()) {
      return res
        .status(400)
        .json({ message: "Verification token has expired" });
    }

    // Update MongoDB: mark email as verified
    user.tempToken = null;
    user.tokenExpire = null;
    await user.save();

    // Update SQL: mark librarian as verified
    await Librarian.update(
      { is_verified: true },
      { where: { librarian_id: user.referenceId } }
    );
    //find librarian's library id
    const tempLibId = await Librarian.findOne({
      attributes: ["lib_id"],
      where: {
        librarian_id: user.referenceId,
      },
    });
    if (!tempLibId) {
      return res.status(404).json({ message: "Library not found" });
    }
    //increamnet that library's librarian count as librarian verify account
    await Library.increment("total_librarians", {
      by: 1,
      where: { lib_id: tempLibId.dataValues.lib_id },
    });
    res.send(LibrarianVerifiedHTML());
  } catch (error) {
    console.error("Error verifying librarian:", error);
    res.status(500).json({ message: "Internal Server Error" });
  }
};

exports.LoginLibrarian = async(req, res) => {
  await handleLogin({role : "librarian",req, res,});
}

exports.Librariandata = async (req, res) => {
  try {
    const librarian_data = await Librarian.findOne({
      where: { librarian_id: req.user.referenceId }, //librarin data from sql
    });
    const library_data = await Library.findOne({
      //librariy data from sql
      where: { lib_id: librarian_data.lib_id },
    });
    //remove all the id's and password
    userData = req.user;
    userData._id = null;
    userData.password = null;
    userData.referenceId=null;
    const cleanedLibrarian = { ...librarian_data.dataValues };
    const cleanedLibrary = { ...library_data.dataValues };
    delete cleanedLibrarian.lib_id;
    delete cleanedLibrarian.librarian_id;
    delete cleanedLibrary.lib_id;
    //parse public id from full URL
    const fullUrl = userData.profilePicUrl;
    const urlParts = fullUrl.split("/upload/");
    const publicIdWithVersion = urlParts[1]; 
    const publicId = publicIdWithVersion.replace(/^v\d+\//, ""); // remove version
    userData.profilePicUrl = getSignedUrl(publicId);
    const FinalData = {
      library_data: cleanedLibrary,
      librarian_data: cleanedLibrarian,
      userData,
    };

    res.status(200).json({ Data:  FinalData});
  }
  catch (error) {
    console.log(error);
    res.status(500).json({ error });
  }
};