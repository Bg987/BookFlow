const { v4: uuidv4 } = require("uuid");
const bcrypt = require("bcrypt");
const { uploadToCloudinary } = require("../config/cloudinary");
const Username = require("../models/username");
const Librarian = require("../models/Librarian");
const Library = require("../models/Library");
const { handleLogin } = require("../utils/logincommon");
const { handleVerify } = require("../utils/verifyCommon");
const { sendMail } = require("../config/mail");
const { getSignedUrl } = require("../config/cloudinary");
const {
  addLibrarianEmail,
  AccountverifiedHTML,
} = require("../utils/EmailsTemplate");

exports.addLibrarian = async (req, res) => {
  let Uid;
  try {
    const lib_id = req.user.referenceId; // library referenceId from middleware
    const { name, dob, email, username } = req.body;
    const profilePic = req.file;

    // Basic validation
    if (!name || !dob || !email || !username || !profilePic) {
      return res.status(400).json({ message: "All fields are required" });
    }
    const dateOfBirth = new Date(dob);
    const today = new Date();
    if (isNaN(dateOfBirth.getTime())) {
      return res.status(400).json({ message: "Invalid date of birth format." });
    }
    if (dateOfBirth > today) {
      return res
        .status(400)
        .json({ message: "Date of birth cannot be in the future." });
    }
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(email)) {
      return res.status(400).json({ message: "Invalid email format." });
    }
    const nameRegex = /^[A-Za-z0-9_]+$/;
    const cleanUsername = username.trim();
    if (!nameRegex.test(cleanUsername)) {
  return res.status(400).json({
    message: "Username must contain only letters, numbers, or underscores.",
  });
}
    // Database validation
    const usernameExists = await Username.findOne({ username });
    if (usernameExists)
      return res.status(400).json({ message: "Username already taken." });

    const emailExists = await Username.findOne({ email });
    if (emailExists)
      return res.status(409).json({ message: "Email already registered" });

    // Generate credentials and unique IDs
    const randomPassword = Math.random().toString(36).slice(-8);
    const hashedPassword = await bcrypt.hash(randomPassword, 10);
    const uniqueId = uuidv4();
    Uid = uniqueId;

    // Verification token setup
    const verificationToken = uuidv4();
    const verificationExpire = new Date(Date.now() + 1000 * 60 * 60 * 24 * 15); // 15 days

    // Step 1: Insert into MongoDB
    const newUser = await Username.create({
      username,
      email,
      password: hashedPassword,
      role: "librarian",
      referenceId: uniqueId,
      tempToken: verificationToken,
      tokenExpire: verificationExpire,
    });

    // Step 2: Insert into SQL
    const newLibrarian = await Librarian.create({
      librarian_id: uniqueId,
      lib_id,
      name,
      dob,
    });

    // Step 3: Respond immediately to the client
    res.status(201).json({
      message:
        "Librarian added successfully",
    });

    // Step 4: Run Cloudinary upload + email in background
    (async () => {
      try {
        // Upload profile picture
        const profilePicUrl = await uploadToCloudinary(
          profilePic.buffer,
          "BookFlow/Profile_Pictures/librarians",
          "librarian_"
        );
        newUser.profilePicUrl = profilePicUrl;
        await newUser.save();

        // Prepare verification email
        const verifyLink = `${process.env.BACKEND_URL}/api/librarian/verify-librarian?token=${verificationToken}`;
        const subject = "BookFlow Librarian Account Created";
        const mailData = addLibrarianEmail(
          name,
          username,
          randomPassword,
          verifyLink
        );
        console.log(mailData);
        // Send email
        await sendMail(email, subject, mailData);
      } catch (err) {
        console.error("Background task failed:", err);
      }
    })();
  } catch (error) {
    if (Uid) {
      try {
        // Rollback if something fails before responding
        await Username.deleteOne({ referenceId: Uid });
        await Librarian.destroy({ where: { librarian_id: Uid } });
      } catch (rollbackError) {
        console.error("Rollback failed:", rollbackError);
      }
    }
    console.error("Error in addLibrarian:", error);
    if (!res.headersSent) {
      res.status(500).json({ message: "Internal Server Error" });
    }
  }
};

exports.verifyLibrarian = async (req, res) => {
  try {
    const { token } = req.query;
    const user = await Username.findOne({ tempToken: token });
    const resVerify = await handleVerify({ req, res, token });
    if (!resVerify) {
      return;
    }
    //find librarian's library id
    const tempLibId = await Librarian.findOne({
      attributes: ["lib_id"],
      where: {
        librarian_id: user.referenceId,
      },
    });
    if (!tempLibId) {
      return res.status(404).json({ message: "Library not found" });
    }
    //increamnet that library's librarian count as librarian verify account
    await Library.increment("total_librarians", {
      by: 1,
      where: { lib_id: tempLibId.dataValues.lib_id },
    });
    res.send(AccountverifiedHTML(role="librarian"));
  } catch (error) {
    console.error("Error verifying librarian:", error);
    res.status(500).json({ message: "Internal Server Error" });
  }
};

exports.LoginLibrarian = async (req, res) => {
  await handleLogin({ role: "librarian", req, res });
};

exports.Librariandata = async (req, res) => {
  try {
    const librarian_data = await Librarian.findOne({
      where: { librarian_id: req.user.referenceId }, //librarin data from sql
    });
    const library_data = await Library.findOne({
      //librariy data from sql
      where: { lib_id: librarian_data.lib_id },
    });
    //remove all the id's and password
    userData = req.user;
    userData._id = null;
    userData.password = null;
    userData.referenceId = null;
    const cleanedLibrarian = { ...librarian_data.dataValues };
    const cleanedLibrary = { ...library_data.dataValues };
    delete cleanedLibrarian.lib_id;
    delete cleanedLibrarian.librarian_id;
    delete cleanedLibrary.lib_id;
    //parse public id from full URL
    const fullUrl = userData.profilePicUrl;
    const urlParts = fullUrl.split("/upload/");
    const publicIdWithVersion = urlParts[1];
    const publicId = publicIdWithVersion.replace(/^v\d+\//, ""); // remove version
    userData.profilePicUrl = getSignedUrl(publicId);
    const FinalData = {
      library_data: cleanedLibrary,
      librarian_data: cleanedLibrarian,
      userData,
    };
    res.status(200).json({ Data: FinalData });
  } catch (error) {
    console.log(error);
    res.status(500).json({ error });
  }
};
