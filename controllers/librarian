const { v4: uuidv4 } = require("uuid");
const bcrypt = require("bcrypt");
const {uploadToCloudinary} = require("../config/cloudinary");
const Username = require("../models/username");
const Librarian = require("../models/Librarian");
const Library = require("../models/Library");
const { handleLogin } = require("../utils/logincommon");
const { handleVerify } = require("../utils/verifyCommon");
const { sendMail } = require("../config/mail");
const { getSignedUrl } = require("../config/cloudinary");
const { createUser } = require("../utils/create");
const {addLibrarianEmail,LibrarianVerifiedHTML} = require("../utils/EmailsTemplate");

exports.addLibrarian = async (req, res) => {
  let Uid;
  try {
    const lib_id = req.user.referenceId; // library referenceId from middleware
    const { name, dob, email, username } = req.body;
    const profilePic = req.file;

    // Basic validation
    if (!name || !dob || !email || !username || !profilePic) {
      return res.status(400).json({ message: "All fields are required" });
    }
    const randomPassword = Math.random().toString(36).slice(-8);
    const { referenceId, tempToken } = await createUser(
      username,
      email,
      randomPassword,
      "librarian",
      res,
    );
    console.log(referenceId);
    Uid = referenceId; // for rollback purpose
    const dateOfBirth = new Date(dob);
    const currentYear = new Date();
    if (dateOfBirth > currentYear) {
      return res
        .status(400)
        .json({ message: "Birth Date cannot be in the future." });
    }
    // Step 2: Insert into SQL
    const newLibrarian = await Librarian.create({
      librarian_id: referenceId,
      lib_id,
      name,
      dob,
    });
    // Step 3: Respond immediately to the client
    res.status(201).json({
      message:
        "Librarian added successfully. Image upload and email are being processed in background.",
    });

    // Step 4: Run Cloudinary upload + email in background
    (async () => {
      try {
        // Upload profile picture
        const profilePicUrl = await uploadToCloudinary(
          profilePic.buffer,
          "BookFlow/Profile_Pictures/librarians",
          "librarian_"
        );
        await Username.updateOne(
          { referenceId },
          { $set: { profilePicUrl} }
        );

        // Prepare verification email
        const verifyLink = `${process.env.BACKEND_URL}/api/librarian/verify-librarian?token=${tempToken}`;
        const subject = "BookFlow Librarian Account Created";
        const mailData = addLibrarianEmail(
          name,
          username,
          randomPassword,
          verifyLink
        );
        console.log(mailData);
        // Send email
        await sendMail(email, subject, mailData);
      } catch (err) {
        console.error("Background task failed:", err);
      }
    })();
  } catch (error) {
    if (Uid) {
      try {
        // Rollback if something fails before responding
        await Username.deleteOne({ referenceId: Uid });
        await Librarian.destroy({ where: { librarian_id: Uid } });
      } catch (rollbackError) {
        console.error("Rollback failed:", rollbackError);
      }
    }
    console.error("Error in addLibrarian:", error);
    if (!res.headersSent) {
      res.status(500).json({ message: "Internal Server Error" });
    }
  }
};

exports.verifyLibrarian = async (req, res) => {
  try {
    const { token } = req.query;
    const user = await Username.findOne({ tempToken: token });
    const resVerify = await handleVerify({ req, res, token});
    if (!resVerify) {
      throw error("common verify error");
    }
    //find librarian's library id
    const tempLibId = await Librarian.findOne({
      attributes: ["lib_id"],
      where: {
        librarian_id: user.referenceId,
      },
    });
    if (!tempLibId) {
      return res.status(404).json({ message: "Library not found" });
    }
    //increamnet that library's librarian count as librarian verify account
    await Library.increment("total_librarians", {
      by: 1,
      where: { lib_id: tempLibId.dataValues.lib_id },
    });
    res.send(LibrarianVerifiedHTML());
  } catch (error) {
    console.error("Error verifying librarian:", error);
    res.status(500).json({ message: "Internal Server Error" });
  }
};

exports.LoginLibrarian = async (req, res) => {
  
  await handleLogin({role : "librarian",req, res,});
}

exports.Librariandata = async (req, res) => {
  try {
    const librarian_data = await Librarian.findOne({
      where: { librarian_id: req.user.referenceId }, //librarin data from sql
    });
    const library_data = await Library.findOne({
      //librariy data from sql
      where: { lib_id: librarian_data.lib_id },
    });
    //remove all the id's and password
    userData = req.user;
    userData._id = null;
    userData.password = null;
    userData.referenceId=null;
    const cleanedLibrarian = { ...librarian_data.dataValues };
    const cleanedLibrary = { ...library_data.dataValues };
    delete cleanedLibrarian.lib_id;
    delete cleanedLibrarian.librarian_id;
    delete cleanedLibrary.lib_id;
    //parse public id from full URL
    const fullUrl = userData.profilePicUrl;
    const urlParts = fullUrl.split("/upload/");
    const publicIdWithVersion = urlParts[1]; 
    const publicId = publicIdWithVersion.replace(/^v\d+\//, ""); // remove version
    userData.profilePicUrl = getSignedUrl(publicId);
    const FinalData = {
      library_data: cleanedLibrary,
      librarian_data: cleanedLibrarian,
      userData,
    };
    res.status(200).json({ Data:  FinalData});
  }
  catch (error) {
    console.log(error);
    res.status(500).json({ error });
  }
};